const INT_SIZE = 32;

class BitVector {
	private bits: number[];

	/**
	 * Конструктор для создания битового вектора определенного размера.
	 *
	 * Визуализация:
	 * Представьте, что нам нужно создать битовый вектор размером 100.
	 *
	 * 1. Мы делим размер на INT_SIZE (32), чтобы определить,
	 * 	  сколько 32-битных чисел нам нужно для хранения битов.
	 *    В данном случае, 100 / 32 даст нам 3.125
	 *
	 * 2. Затем мы округляем полученное число вверх, чтобы получить целое число.
	 *    Math.ceil(3.125) даст нам 4.
	 *
	 * 3. Затем мы создаем новый массив длиной 4 и заполняем его нулями.
	 *    Это наш битовый вектор.
	 */
	constructor(size: number) {
		this.bits = new Array(Math.ceil(size / INT_SIZE)).fill(0);
	}

	private outOfRangeAssertion(bit: number) {
		if (bit >= this.bits.length * INT_SIZE) {
			throw new Error('Bit value is out of range');
		}
	}

	/**
	 * Возвращает индекс строки для бита в массиве 32-битных чисел.
	 *
	 * Визуализация:
	 * Представьте, что у нас есть 32-битное число и мы хотим узнать,
	 * в какой строке массива оно находится.
	 *
	 * 1. Операция сдвига вправо на 5 бит эквивалентна делению на 2^5 (или 32).
	 *    Это быстрее, чем обычное деление, и дает тот же результат, что и Math.floor(bit / 32).
	 */
	private getBitRow(bit: number) {
		return bit >> 5;
	}

	/**
	 * Возвращает позицию бита внутри 32-битного числа.
	 *
	 * Визуализация:
	 * Представьте, что у нас есть 32-битное число и мы хотим узнать позицию бита внутри этого числа.
	 *
	 * 1. INT_SIZE - 1 даст нам 31 (INT_SIZE равно 32, так как мы работаем с 32-битными числами).
	 *    Это число в двоичном формате будет выглядеть как 11111 (5 битов в 1).
	 *
	 * 2. Затем мы делаем операцию И с исходным числом.
	 *    Это гарантирует, что мы получим остаток от деления исходного числа на 32.
	 *    Это эквивалентно операции bit % 32, но выполняется быстрее.
	 */
	private getBitCol(bit: number) {
		// is equal to bit % 32
		return bit & (INT_SIZE - 1);
	}

	/**
	 * Устанавливает бит в позиции, указанной индексом, в 1.
	 *
	 * Визуализация:
	 * Представьте, что у нас есть битовый вектор: 0000 0000 (8 бит)
	 * Если мы хотим установить бит на позиции 3 в 1, мы делаем следующее:
	 *
	 * 1. Сдвигаем 1 на нужную нам позицию. В данном случае, это будет 3.
	 *    1 << 3 даст нам 0000 1000
	 *
	 * 2. Затем мы делаем операцию ИЛИ с исходным битовым вектором.
	 *    Это гарантирует, что бит на позиции 3 будет установлен в 1,
	 * 	  а все остальные биты останутся неизменными.
	 *    0000 0000 | 0000 1000 даст нам 0000 1000
	 */
	set(index: number) {
		this.outOfRangeAssertion(index);

		const row = this.getBitRow(index);
		const col = this.getBitCol(index);

		this.bits[row] |= 1 << col;
	}

	/**
	 * Сбрасывает бит в позиции, указанной индексом, в 0.
	 *
	 * Визуализация:
	 * Представьте, что у нас есть битовый вектор: 0000 1000 (8 бит)
	 * Если мы хотим сбросить бит на позиции 3 в 0, мы делаем следующее:
	 *
	 * 1. Сдвигаем 1 на нужную нам позицию. В данном случае, это будет 3.
	 *    1 << 3 даст нам 0000 1000
	 *
	 * 2. Затем мы инвертируем полученный битовый вектор.
	 *    Это гарантирует, что бит на позиции 3 будет 0, а все остальные биты будут 1.
	 *    ~(0000 1000) даст нам 1111 0111
	 *
	 * 3. Затем мы делаем операцию И с исходным битовым вектором.
	 *    Это гарантирует, что бит на позиции 3 будет сброшен в 0,
	 * 	  а все остальные биты останутся неизменными.
	 *    0000 1000 & 1111 0111 даст нам 0000 0000
	 */
	unset(index: number) {
		this.outOfRangeAssertion(index);

		const row = this.getBitRow(index);
		const col = this.getBitCol(index);

		this.bits[row] &= ~(1 << col);
	}

	/**
	 * Проверяет, установлен ли бит в позиции, указанной индексом, в 1.
	 *
	 * Визуализация:
	 * Представьте, что у нас есть битовый вектор: 0000 1000 (8 бит)
	 * Если мы хотим проверить, установлен ли бит на позиции 3, мы делаем следующее:
	 *
	 * 1. Сдвигаем 1 на нужную нам позицию. В данном случае, это будет 3.
	 *    1 << 3 даст нам 0000 1000
	 *
	 * 2. Затем мы делаем операцию И с исходным битовым вектором.
	 *    Это гарантирует, что только бит на позиции 3 будет учтен.
	 *    0000 1000 & 0000 1000 даст нам 0000 1000
	 *
	 * 3. Если результат не равен 0, это означает, что бит на позиции 3 был установлен в 1.
	 */
	isSet(index: number): boolean {
		this.outOfRangeAssertion(index);

		const row = this.getBitRow(index);
		const col = this.getBitCol(index);

		return (this.bits[row] & (1 << col)) !== 0;
	}

	/**
	 * Инвертирует бит в позиции, указанной индексом.
	 *
	 * Визуализация:
	 * Представьте, что у нас есть битовый вектор: 0000 1000 (8 бит)
	 * Если мы хотим инвертировать бит на позиции 3, мы делаем следующее:
	 *
	 * 1. Сдвигаем 1 на нужную нам позицию. В данном случае, это будет 3.
	 *    1 << 3 даст нам 0000 1000
	 *
	 * 2. Затем мы делаем операцию XOR с исходным битовым вектором.
	 *    Это гарантирует, что бит на позиции 3 будет инвертирован,
	 * 	  а все остальные биты останутся неизменными.
	 *    Если бит был 1, он станет 0, и наоборот.
	 *    0000 1000 ^ 0000 1000 даст нам 0000 0000 (если бит был 1)
	 *    0000 0000 ^ 0000 1000 даст нам 0000 1000 (если бит был 0)
	 */
	inverse(index: number) {
		this.outOfRangeAssertion(index);

		const row = this.getBitRow(index);
		const col = this.getBitCol(index);

		this.bits[row] ^= 1 << col;
	}
}

export default BitVector;
